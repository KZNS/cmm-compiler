# Cmm 编译器文档

本文档包含本项目编译器从词法分析到中间代码生成与执行，和最后ui的全部技术内容。

## 目录 <!-- omit in toc -->

- [1. 项目概述](#1-项目概述)
  - [1.1. 概述](#11-概述)
  - [1.2. 功能概述](#12-功能概述)
  - [1.3. 代码结构](#13-代码结构)
- [2. 词法分析](#2-词法分析)
  - [2.1. 词法分析概述](#21-词法分析概述)
  - [2.2. 词法规则整理](#22-词法规则整理)
  - [2.3. 字典树](#23-字典树)
  - [2.4. 类正则表达式生成DFA](#24-类正则表达式生成dfa)
- [3. 语法分析](#3-语法分析)
  - [3.1. 递归下降子程序](#31-递归下降子程序)
  - [3.2. 探测函数](#32-探测函数)
- [4. 语义分析](#4-语义分析)
  - [4.1. 属性传递](#41-属性传递)
  - [4.2. 符号表](#42-符号表)
- [5. 中间代码定义](#5-中间代码定义)
  - [5.1. 变量声明](#51-变量声明)
  - [5.2. 栈操作](#52-栈操作)
  - [5.3. 数据运算](#53-数据运算)
  - [5.4. 输入输出](#54-输入输出)
  - [5.5. 退出](#55-退出)
  - [5.6. 跳转](#56-跳转)
  - [5.7. 自定义函数](#57-自定义函数)
- [6. 中间代码生成](#6-中间代码生成)
  - [6.1. 变量与常量定义](#61-变量与常量定义)
  - [6.2. 函数定义与调用](#62-函数定义与调用)
  - [6.3. 表达式](#63-表达式)
  - [6.4. 分支与循环](#64-分支与循环)
  - [6.5. 中间代码格式化](#65-中间代码格式化)
- [7. 解释执行](#7-解释执行)
  - [7.1. 主要数据结构](#71-主要数据结构)
  - [7.2. 简要说明](#72-简要说明)
  - [7.3. 主要命令处理实现](#73-主要命令处理实现)
- [8. 用户界面](#8-用户界面)

## 1. 项目概述

### 1.1. 概述

### 1.2. 功能概述

见 [README.md](../README.md)

### 1.3. 代码结构

项目主体分为两个部分，编译器/解释器部分和前端部分。  

```text
.
├── run          启动脚本
├── compiler     编译器/解释器部分
└── webservice   前端UI部分
```

编译器/解释器部分：

```text
.
├── compiler.exe            编译器可执行文件
├── language.txt            词法规则
├── compiler.cpp            编译器入口
├── automaton.h             词法分析部分
├── automaton.cpp
├── translator.h            语法、语义部分
├── translator.cpp
├── symbol_table.h          符号表部分
├── symbol_table.cpp
├── pcode_interpreter.exe   pcode解释器可执行文件
├── pcode_interpreter.cpp   pcode解释器入口
├── interpreter.h           解释器部分
├── interpreter.cpp
└── cLogger                 log模块
    ├── clogger.cpp
    └── clogger.h
```

UI部分：

```text
.
├── cmm.go              服务器后端
├── go.mod
├── go.sum
├── requirements.txt
└── templates           网页模板
    └── index.html
```

## 2. 词法分析

### 2.1. 词法分析概述

词法分析需要将代码中的字符分割成单词，然后返回给上层的语法分析进行进一步的处理。在语法分析的阶段，不仅需要正确获取单词，还要可以正确的处理错误单词和文件结尾。  
朴素的词法分析是通过代码根据读入的字符进行处理，整个过程依靠if-else，类似与DFA的处理流程。但是这样的处理方的问题在于，代码量与词法规则的复杂程度直接相关，并且一个复杂的关键字会对应代码中一段很深的if嵌套。当然这种方法非常容易实现，但是所处理的词法与代码的强耦合是没有必要的。  
这里我们通过读入词法规则，自动构建DFA，从而进行词法分析。这样做的好处是，词法与代码解耦合，可以方便的变更词法，包括对符号构成的运算符进行变更，如'{'改为'begin'；代码与数据分离，方便代码的编写，提高代码重用程度；相比于单独查表判断是关键字还是标识符，DFA效率更高。  

### 2.2. 词法规则整理

首先我们整理了词法规则，将词法规则分为两类，一类为简单的固定规则，如‘int’，‘char’，‘==’，‘{’等确定的运算符或关键字；另一类为动态规则，标识符、数字、字符串常量、字符常量，并不是以固定的一种字符串形式出现的单词。  

词法规则见[词法规则表](../compiler/language.txt)

部分固定的词法规则：

```test
CONSTTK const
INTTK int
CHARTK char
VOIDTK void
MAINTK main

IFTK if
ELSETK else
WHILETK while
FORTK for
PLUS +
MINU -

LBRACE {
RBRACE }
```

动态的词法规则：

```text
IDENFR _a~zA~Z|_a~zA~Z0~9
INTCON 0~9
CHARCON '|+-*/_a~zA~Z0~9|'
STRCON "|\032\033\035~\126|"
```

对于固定的单词，我们使用字典树的方式维护这些运算符和关键字。对于动态的单词，我们定义了一种类似正则表达式的式子，通过这些式子描述词法，然后在字典树的基础上生成DFA。

### 2.3. 字典树

字典树是一种树型数据结构，树上的每一个节点表示一个状态，每一条边表示一个字符，从树根到当前节点的路径上的字符组成了一个字符串。  
一个字典树的例子如下。  

![字典树示例](img/trie_tree.svg)

如图从1到6号节点的路径对应了单词“const”。  
词法分析程序从根节点开始，按照读入的字符，沿字典树前进。如果读入字符串可以匹配一个关键字，那么它会沿字典树走到相应状态，如果在一个合法的单词结尾处失配，那么说明当前的一个单词已经读完，否则说明读入了一个错误的单词。我们在每个合法的单词结尾处标记了单词的类别，这样在得到一个合法单词之后，可以直接得到对应的类别码。  
可以看到，具有相同前缀的字符串共用祖先节点，所以不会出现需要反复匹配前缀的情况，提高了词法分析的处理效率。同时字典树可以很方便地插入新单词，可以直接从文件中读出单词然后生成字典树。  

### 2.4. 类正则表达式生成DFA

我们定义了一种类似正则表达式的语句来描述动态单词的词法。  
示例如下：

```text
IDENFR _a~zA~Z|_a~zA~Z0~9
INTCON 0~9
CHARCON '|+-*/_a~zA~Z0~9|'
STRCON "|\032\033\035~\126|"
```

通过`|`将表达式分为1到3个部分。每一个部分内表示可以被接受的字符范围，如`_a~zA~Z`表示下划线、全部小写字母、全部大写字母；`\032\033\035~\126`表示ASCII码为32，33，35到126的全部字符。  
如果表达式只有一段，那么这个单词由这一段可接受字符重复组合而成，如可以前导0的数字。如果有两段，这个单词由一个第一段可接受字符和一些第二段可接受字符组成，如第一位不可以是数字的标识符。如果有三段，则这个单词可以由一个第一段字符开始，第二段字符在中间，一个第三段字符结束，如引号引起的字符串。  
这样的设计并不复杂，可以描述出需要的动态单词的词法，并且也很好修改，同时还为未来可能的全功能正则表达式支持留下接口。  
在成功读入词法信息后，我们在字典树的基础上添加一些边，使得树形结构变成一个能够接受动态单词DFA。

![DFA图例](img/DFA.svg)

如图我们添加了一个点11，表示一个“标识符”，我们将失配但是符合标识符规则的节点全部连过来，这样无论在任何一个状态下，发现读入单词不是一个关键字的时候，状态都可以正常的转移到标识符处。其他几种词法同理。

## 3. 语法分析

语法分析是整个编译器处理的核心，它调用词法分析获取单词，处理语法的同时通过语义检查语义正确行，通过在语法分析的过程中生成合适的中间代码。在这一部分，我们使用递归下降子程序的方式进行语法分析，通过统一的函数来输出语法分析信息，通过一个探测函数来处理容易产生歧义的语法。

### 3.1. 递归下降子程序

递归下降子程序对每一个语法的非终结状态创建一个函数，然后通过函数调用的方式进入另一个非终结状态。这样的方式十分方便代码的实现，因为代码结构与语法定义的结构几乎是相同的。  
在分析的过程中，语法分析直接使用词法分析处理得到的单词进行分析。由于在词法分析的时候，我们使用了词法规则表来让词法与代码解耦合，所以在语法分析阶段，也将对单词的类别进行识别，而不关心单词实际的值是什么。  
首先我们根据语法，为每个中间状态进行了分类，然后生成了对应的函数：  

```c++
int prog(); // 程序

int declare_const(); // 常量说明
int def_const();     // 常量定义
int declare_var();   // 变量说明
int def_var();       // 变量定义

int uinteger(unsigned int &x); // 无符号整数
int integer(int &x);           // 整数

int declare_h(std::string &type, std::string &name); // 声明头部
int f_ret();                                         // 有返回值函数定义
int f_void();                                        // 无返回值函数定义
int param_table(std::vector<VarProperty> &arg_list); // 参数表

int main_f(); // 主函数

int comp_stmt(std::string ret_type, bool &returned); // 复合语句
int stmt_list(std::string ret_type, bool &returned); // 语句列
int stmt(std::string ret_type, bool &returned);      // 语句
int eval();                                          // 赋值语句
int cond_stmt(std::string ret_type, bool &returned); // 条件语句
int cond();                                          // 条件
int loop_stmt(std::string ret_type, bool &returned); // 循环语句
int step(unsigned int &x);                           // 步长

int exp(std::string &type);    // 表达式
int term(std::string &type);   // 项
int factor(std::string &type); // 因子

int f_ret_call(std::string &ret_type);            // 有返回值函数调用语句
int f_void_call();                                // 无返回值函数调用语句
int arg_list(std::vector<VarProperty> &arg_list); // 值参数表

int r_stmt();                       // 读语句
int w_stmt();                       // 写语句
int ret_stmt(std::string ret_type); // 返回语句

int str_const(std::string &str); // 字符串
```

在一个中间状态函数内，只需要处理当前语法所关注的部分，然后选择合适的函数进行调用。以“项”为例子：  
项的语法定义为 `<term> ::= <factor>{<mult_op><factor>}`，即以一个因子为首，后跟0或多个乘除号与因子，其对应的代码为：  

```c++
int GrammarTranslator::term(std::string &type)
{
    factor(type);
    while (word.first == "MULT" || word.first == "DIV")
    {
        op = word.first;
        get_word();
        factor(type_b);
    }
    print_grammar("<项>");
    return 0;
}
```

实际代码中包含关于语义与中间代码生成的部分内容，但是其语法处理的核心部分如上。可以看到，这样的一个函数在开头调用了因子，然后通过一个循环来实现多个乘除号与因子的情况。  
在完成语法的分类与函数定义之后，语法分析基本上只是将语法规则翻译为代码即可。同时，为了输出语法信息，我们使用来一个统一的函数 `print_grammar()` 来输出语法信息，该函数会编译开关选择是否输出语法信息。  
由于初始的语法分析函数定义部分比较相似且繁琐，实际编写中我们使用了python脚本根据语法表直接生成部分代码，包括所有语法函数的声明、注释，以及基本的声明（包括输出语法信息）。

### 3.2. 探测函数

由于语法规则本身并不是LL(1)文法，只看一个单词有时候并不能确定进入那个状态，我们使用了一个探测函数 `detect()` 和一个单词缓冲区 `word_buffer` 解决了状态无法区分的问题。  
一般情况下，我们从词法分析取出的单词不可以放回，如果需要根据后续的几个单词判断当前函数的调用问题，需要手动维护已经读入单词的词法信息。但是这样会使得函数内面对的“当前单词”的状态并不统一，使得函数内需要处理超出函数职能的语法信息。于是当我们遇到一个无法通过当前单词判断的语法歧义时，我们可以调用detect函数对接下来的几个单词进行判断，然后恢复单词缓冲区的状态，从而使得这样的一个判断并不会对后续的处理带来影响。  
如定义变量 `int a;` 与定义有返回值的函数 `int a(){}` 在初始的两个单词上并无区别，只有读到第三个单词的时候，如果是"("，则说明是函数定义，否则是变量定义。  

实际代码中探测方式如下：

```c++
if ((detect(2, "INTTK", "IDENFR") && !detect(3, "INTTK", "IDENFR", "LPARENT")) ||
    (detect(2, "CHARTK", "IDENFR") && !detect(3, "CHARTK", "IDENFR", "LPARENT")))
{
    declare_var();
}
```

当前两个单词是变量类型、标识符，且第三个单词不是“(”的时候，才调用 `declare_var()` 函数，进入变量定义的部分。

## 4. 语义分析

语义分析的目的是进行为中间代码生成提供信息，在分析的同时对语义错误进行检查处理。  
我们首先通过参数和引用参数的方式进行属性的传递，然后通过一个符号表类对代码中出现的标识符进行维护。

### 4.1. 属性传递

一个语义所需的信息并不一定在一个函数内可以得到，所以不同语法中间状态间需要传递继承属性或综合属性，这里通过参数和引用参数的方式进行属性信息的传递。  
这样传递信息的好处在于灵活。通过参数列表，我们可以传递任意个数、任意种类的属性，以满足属性传递的需求，并且在代码编写的时候，可以轻易的变更参数内容以方便功能的变更或者bug的修复。由于在最开始编写的时候很难直接向想到全部需要的语义信息，修改函数表还可以在编译阶段方便的发现代码中没有正确输入参数或者返回参数的地方。  

### 4.2. 符号表

符号表是语义分析的核心，代码中的语义信息全部围绕这用户自定义的函数和变量展开。通过符号表管理这些标识符，从而判断用户操作的正确行以及操作元素的具体对象。  
符号表类主要由全局变量表、局部变量表、函数表组成，包括一些在这些表中查询的方法。  

```c++
class SymbolTable
{
private:
    std::map<std::string, VarProperty> global_var_table, local_var_table;
    std::map<std::string, FunctionProperty> f_table;
    bool is_local;

public:
    SymbolTable();
    int insert_var(const VarProperty &var_p);
    int insert_f(const FunctionProperty &func_p);

    VarProperty *find_var(const std::string &name);
    FunctionProperty *find_f(const std::string &name);

    int local_var_table_clear();
    int set_local();
    int set_global();
};
```

变量和函数的未定义、重定义，变量的数据类型、函数的参数列表等信息，都可以在符号表中直接查到，以解决语义上的问题。  
局部变量和全局变量的管理是符号表尤其需要注意的地方。我们在开始定义一个函数的时候，通过 `set_local()` 将符号表置为局部状态，之后新定义的变量全部放入局部变量表，并且在查询变量的时候，也会先查询局部变量表，实现局部变量与全局变量可以重名，且优先调用局部变量的效果。  

## 5. 中间代码定义

通过查阅与参考相关资料我们设计了一种自定义的结合了逆波兰式的逻辑和pascal编译器的中间代码的，基于栈和符号表的中间代码，我们称之为PCode。  
PCode的命令格式为`"命令 操作数"`，其中操作数可以是数字(int32)或变量名。PCode的注释类似汇编，以“;”开头的命令会被忽略。  
PCode的所有命令都是对栈顶及附近的元素进行操作的。PCode的命令共有7类：变量声明、入栈出栈、数据运算、输入输出、退出、跳转、自定义函数。下面分别详细介绍上述7种命令。

### 5.1. 变量声明

通过`var`命令声明变量，并分配需要的空间。有以下用法：  

```pcode
var a           ; 栈顶向下增长 1 个单元，将新的栈顶单元分配（绑定）给 a
var x, y, z     ; 栈顶向下增长 3 个单元，将新的栈顶单元分配（绑定）给 x, y, z
```

### 5.2. 栈操作

`push / pop` 命令，将元素放入栈顶，或取出栈顶元素。有以下用法：

```pcode
push 2          ; 将常数 2 入栈
push a          ; 将变量 a 的值入栈， a 必须已被声明、且已被赋值过
pop             ; 将栈顶向上减少一个单位
pop a           ; 取出栈顶元素，并赋给变量 a ， a 必须已被声明
```

### 5.3. 数据运算

`add / sub / mul / div / mod / cmpeq / cmpne / cmpgt / cmplt / cmpge / cmple / and / or / not / neg` 命令，包括算术、比较和逻辑运算命令。对应于C语言的以下运算符：`+, -, *, /, %, ==, !=, >, <, >=, <=, &&, ||, !, -`  

以上命令中，除 `not` 和 `neg` 命令外，其余命令均为二元操作命令，先取出栈顶两个元素，进行运算后，再将结果放回栈顶， `not` 和 `neg` 命令则为一元操作命令，只对栈顶一个元素进行操作。所有二元操作中， 原栈顶元素是第二个操作符 。  
以cmpgt为例：进行的操作是

- 从栈顶取出操作数op1
- 取除新栈顶的操作数op2进行比较
- 如果op1&lt;op2则结果为真，否则为假。
- 将结果写入运算栈顶

### 5.4. 输入输出

`print/input`命令。有以下用法：

```pcode
print a:int       ;输出类型是int的变量a的值
print "Helo"      ;输出字符串
print b:char,"bye";以字符形式输出变量b的值代表的ascii码拼接字符串"bye"
input a:char      ;输入char类型的值赋给变量a
input c:int,b:char;输入int类型的值赋给变量c以及char类型的值赋给变量b
```

### 5.5. 退出

`exit <value:int>|~`命令。有以下用法：

```pcode
exit 5            ;命令解释器直接退出，解释器的返回值会是5
exit ~            ;按栈顶元素退出，返回值是栈顶元素值
```

### 5.6. 跳转

`jmp/jz/jnz`命令。

- `jmp` 命令为无条件跳转命令，直接跳转到标签处，用法如下：

```pcode
    jmp Label
    ...
    ...
Label:
    print "jump here"
```

- `jz` 命令为条件跳转命令，先取出栈顶元素，判断其是否为 0 ，若为 0 ，则跳转至标签处，若不为 0 ，则转到下一条命令，用法如下：

```pcode
    push 0
    jz Label
    print "top is not zero"
Label:
    print "top is zero"
```

- `jnz` 命令为条件跳转命令，先取出栈顶元素，判断其是否为 0 ，若为 0 ，则转到下一条命令，若不为 0 ，则跳转至标签处，用法如下：
  
```pcode
    push 1
    jz Label
    print "top is not zero"
Label:
    print "top is zero"
```

### 5.7. 自定义函数

`FUNC / ENDFUNC / arg / ret / $func_name` 命令。
FUNC 和 ENDFUNC 分别为函数开始和结尾，FUNC 后的函数名以 @ 开始，这是为了不与系统命令冲突，因为在 C 语言中有可能会定义一个名为 add 或 push 等和系统命令同名的函数。函数名后接一个冒号。

函数体内开始的第一个命令为 arg ，这是声明函数参数的，注意此命令不能和 FUNC 行写在同一行。如果函数没有参数，则此命令可以去掉。声明了函数参数，函数内部可以根据参数名来引用函数调用者传递进来的参数。

函数调用的时候，在函数名前加 `"$"`就可以了，函数的参数通过栈传递，先从左向右将参数压入栈中，再调用函数。用法如下：

```pcode
push 1
push 2
$sum
 
FUNC @sum:
    arg a, b
 
    push a
    push b
    add
    ret ~
ENDFUNC
```

函数用 ret 命令向调用者返回值，有以下形式：

```pcode
ret         ; 返回空值 “/”
ret 1       ; 返回常数
ret a       ; 返回变量值
ret ~       ; 取出栈顶元素，返回其值。
```

## 6. 中间代码生成

我们将源语言CMM翻译为上文定义的中间代码PCode。通过中间代码，可以将复杂的，包含语义的代码操作转化为简单的基本操作，供后续解释执行使用。  
生成合适的中间代码可以方便解释执行的处理，也可以提高代码的运行效率。  
一下对变量定义、函数定义与调用、表达式、分支与循环几种不同的翻译方式进行说明。

### 6.1. 变量与常量定义

语法分析得到变量标识符和数据类型，并且通过语法检查后，生成格式为 `var <变量名>:<数据类型>` 的中间代码。对于数组，使用 `var <数组名>[<数组大小>]:<数据类型>` 来定义一个数组。由于PCode对变量值的修改必须通过栈进行，对于需要赋初始值的情况，我们在定义变量之后，使用 `push <初始值>` 将变量的初始值押入栈顶，然后使用 `pop <变量名>` 将栈顶元素的值写入变量中，完成变量赋初值的操作。  
CMM代码：

```c
const int ca = 10;
int a;
```

对应PCode代码：

```pcode
var ca:INTTK
push 10
pop ca
var a:INTTK
```

### 6.2. 函数定义与调用

PCode中有定义函数与调用的相关功能，与高级语言定义函数与调用的过程类似。  
在函数定义的头部，使用 `FUNC @<函数名>:` 定义一个函数。在函数定义的末尾，使用 `ENDFUNC` 结束函数的定义。紧接函数头部之后，使用 `arg <参数名>:<数据类型>,...` 定义函数的参数表。对于 `return` 语句，根据是否有返回值，分别翻译为 `ret ~` 返回栈顶元素和 `ret` 没有返回值两种情况。  

CMM代码：

```c
int b(int k)
{
    k = 10;
    return (k);
}
void c()
{
    a = 10;
}
```

对应PCode代码：

```pcode
FUNC @b:
    arg k:INTTK
    push 10
    pop k
    push k
    ret ~
ENDFUNC
FUNC @c:
    arg
    push 10
    pop a
    ret
ENDFUNC
```

在调用函数的时候，首先要按照从左到右的顺序参数的值依次押入栈中，然后再使用 `$<函数名>` 调用函数。如果是有返回值的函数，函数的返回值在返回之后应该存在栈顶，这样的做法方便函数参与表达式的运算。如果不需要函数的返回值（做为过程调用），调用函数的中间代码后会紧跟 `pop` 以删除栈顶的返回值。  

CMM代码：

```c
x = b(a);

b(a);
```

对应PCode代码：

```pcode
push a
$b
pop x

push a
$b
pop
```

### 6.3. 表达式

基于PCode的特性，表达式的中间代码与后缀表达式类似，先将两个操作数入栈，然后使用计算命令根据栈顶两个元素的进行计算，然后将结果放回栈顶。对于一个赋值表达式来说，可以在等式右边计算完成后通过 `pop <变量名>` 将值写入变量。  
一下以一个简单的运算为例子。  

CMM代码：

```c
x = (1-2)*3;
```

对应PCode为：

```pcode
push 1
push 2
sub
push 3
mul
pop x
```

对于调用函数的参数来说，可以直接将栈顶元素做为函数的参数值。由于函数的返回值会被写在栈顶，一个包含函数调用的表达式与上述表达式的形式类似。  

CMM代码：

```c
func_b((1-func(a, b))*3, 6);
```

对应PCode为：

```pcode
push 1
push a
push b
$func
sub
push 3
mul
push 6
$func_b
```

### 6.4. 分支与循环

分支与循环是编程语言中的重要组成部分，这部分的中间代码主要由几个跳转命令和标签实现。  
对于一个 if/else 分支来说，翻译成的PCode格式如下：  

```pcode
If<unique_label>:
    <条件表达式中间代码>
jz Else<unique_label>
    <条件表达式为真时执行的代码>
jmp Endif<unique_label>
Else<unique_label>:
    <条件表达式为假时执行的代码>
Endif<unique_label>:
```

`<条件表达式中间代码>`会按照if语句的条件表达式生成，并将计算的结果放到栈顶。若栈顶元素值为0，`jz <标签>` 将跳转到 `<标签>` 所在行继续执行，否则不会进行跳转。通过这个命令，我们可以在条件表达式的值为假的时候跳转到else部分，否则继续执行紧接着的代码，也就是条件成立时的代码。当`<条件表达式为真时执行的代码>`执行完毕之后，通过 `jmp <标签>` 指令无条件跳转到if/else语句的结尾处。
当`<条件表达式为假时执行的代码>`  
由于代码中可能存在多个if/else的分支语句，对于每一个if/else语句，我们分配了一个唯一的`<unique_label>`，来保证跳转的正确性，尤其是在语句嵌套的时候。  
循环语句生成的中间代码如下。  

while语句翻译为如下PCode：

```pcode
While<unique_label>:
    <条件表达式>
jz EndWhile<unique_label>
    <循环体>
jmp While<unique_label>
EndWhile<unique_label>:
```

do/while语句翻译为如下PCode：

```pcode
Do<unique_label>:
    <循环体>
While<unique_label>:
    <条件表达式>
jnz Do<unique_label>
EndDoWhile<unique_label>:
```

for语句翻译为如下PCode：

```pcode
For<unique_label>:
    <循环变量初始化>
ForCond<unique_label>:
    <条件表达式>
jz EndFor<unique_label>
    <循环体>
ForUpdate<unique_label>:
	<循环变量更新>
jmp ForCond<unique_label>
EndFor0:
```

for循环较为特殊，<循环变量更新>语句虽然在<循环体>的前面出现，但是生成中间代码的时候生成在了循环体的后面。这样做是为了减少跳转语句的数量。

### 6.5. 中间代码格式化

处于效率的考虑，中间代码本来是不需要格式化的，但是做为一个实验性质的项目，我们在输出中间代码的时候进行了一定程度的格式化，使得中间代码有更高的可读性。  
中间代码的格式化与高级语言类似，通过缩进区分代码的层级。函数内的代码会有一个缩进，分支和循环内的代码会有额外的一个缩进。特别的，分支和循环使用标签和跳转语句对语句功能块进行了划分，下面是一个例子。  

CMM代码：

```c
int a;
int b()
{
    return (1);
}
void c()
{
    a = 10;
}
void main()
{
    int i;
    for (i = 0; i < 10; i = i+1)
    {
        if (i <= 5)
        {
            printf(i);
        }
        else
        {
            printf(-i);
        }
    }
}
```

对应PCode代码：

```pcode
var a:INTTK
$main
exit 0
FUNC @b:
    arg
    push 1
    ret ~
ENDFUNC
FUNC @c:
    arg
    push 10
    pop a
    ret
ENDFUNC
FUNC @main:
    arg
    var i:INTTK
    For2:
        push 0
        pop i
    ForCond2:
        push i
        push 10
        cmplt
    jz EndFor2
        If3:
            push i
            push 5
            cmple
        jz Else3
            push i
            print ~:INTTK
        jmp EndIf3
        Else3:
            push i
            neg
            print ~:INTTK
        EndIf3:
    ForUpdate2:
        push i
        push 1
        add
        pop i
    jmp ForCond2
    EndFor2:
    ret
ENDFUNC
```

## 7. 解释执行

在生成中间代码后需要运行之。基于上文定义的简易中间代码语法，我们基于C++设计并实现了一个PCode解释器。

### 7.1. 主要数据结构

由于PCode的所有命令都是对运行时栈顶及其附近的元素进行操作的，我们的解释器也以栈为主要数据结构。它包括:

- 运行时变量栈`std::vector<Variable> runtimeVar`
- 运行时变量速查表`std::stack<std::unordered_map<std::string,int>> runtimeVarLookup`
- 运行时全局变量速查表`std::unordered_map<std::string,int> runtimeGlobLookup`
- 运行时运算栈`std::stack<int> runtimeStack;`
- 标签表`std::unordered_map<std::string,int> labelMap`
- 函数表`std::unordered_map<std::string,int> funcMap`
- 代码表`std::vector<std::vector<std::string>> code`
- 运行时程序指针(PC)`std::stack<int> eip`
- 运行时栈变量栈指针`std::stack<int> old_sp`
- 命令处理函数映射表`std::unordered_map<std::string,int(PcodeInterpreter::*)(const std::string)> cmdHandler`
  
### 7.2. 简要说明

- 两个变量速查表维护的都是变量名对变量栈基址偏移量的映射；标签表和函数表分别维护的是标签名和函数名对代码表基址偏移量的映射。  
- 为了实现函数的递归调用，我们的变量速查表和程序指针都设计成了栈，递归每深入一层就将栈顶的值再次推入栈顶，在函数返回时会弹出栈顶元素(这会在下文中不同命令的实现部分加以进一步说明)。
- 我们通过变量速查表和变量栈来实现变量值的快速访问，同时通过old_sp栈来在函数退出时释放相关局部变量以避免造成内存泄漏。
- 通过维护命令处理函数映射表，我们实现了命令名对处理函数的映射与快速调用`(this->*cmdHandler[cmd[0]])(cmd[1])`。通过使用哈希表实现了相比大段switch-case语句更快的执行速度，同时避免了大段重复代码的编写。
- 解释器在执行代码前会提前遍历一遍PCode，扫描并记录所有标签和函数，并将标签入口和函数入口记录在标签表/函数表中。
  
### 7.3. 主要命令处理实现

- `var`  
  `var`命令接受任意多个逗号分隔的变量名作为参数。  
  解释器会首先在当前栈顶的变量速查表中寻找是否存在重名变量，如果存在则抛出异常并退出；否则将变量填入变量栈中，并把该变量的基址偏移量作为value，变量名作为key填入变量速查表中以实现快速存取访问。
- `push`  
  `push`命令接受一个立即数或变量名作为参数。  
  如果参数不是立即数，解释器会首先在当前栈顶的变量速查表中寻找是否存在该变量名，如果不存在则抛出异常并退出；否则从变量表中取出该变量对应的值(或立即数)填入运行时栈中
- `pop`  
  `pop`命令接受一个变量名作为参数，参数也可为空。  
  解释器会首先检查当前运算栈是否有足够的元素弹出，如果没有则抛出异常并退出。如果参数为空，则直接弹出栈顶元素；如果是变量名，则在检查变量名存在且不是常量后弹出栈顶值并将其赋值给该变量。
- `add`
  `add`命令隐式地使用当前运算栈顶的两个值作为参数。  
  解释器会首先检查当前运算栈是否有两个元素，如果没有则抛出异常并退出。解释器会取出两个栈顶元素相加后填入运算栈中。
- `jmp`
  `jmp`命令为无条件跳转，接受一个标签名作为参数。  
  解释器会首先检查当前标签名是否在标签表中，如果没有则抛出异常并退出。解释器会将当前程序指针栈栈顶元素重新赋值为标签表中记录的过程入口代码表偏移值，会在下一循环中执行标签名所对应的代码段。
- `jz`
  `jz`命令为有条件跳转，只有当前运算栈栈顶值为0时才进行跳转，接受一个标签名作为参数。
  解释器判断并弹出栈顶元素，如果是0则进行跳转(`jmp`)，如果不则继续顺序执行。
- `cmplt`
  `cmplt`命令为比较(小)，隐式地使用当前运算栈顶的两个值作为参数。  
  以cmpgt为例：进行的操作是
  1. 从栈顶取出操作数op1
  2. 取除新栈顶的操作数op2进行比较
  3. 如果op1&lt;op2则结果为真，否则为假。
  4. 将结果写入运算栈顶
- `neg`
  `neg`命令对当前栈顶元素逻辑取反  
  解释器在检查栈内元素个数大于0后对运算栈顶元素逻辑取反。
- `print`
  `print`命令接受"`"分隔的任意多个变量名、""包裹的字符串或"~"代表的栈顶元素作为参数。  
  如果是字符串，则直接打印输出；如果是栈顶元素，在取出栈顶元素值并判断类型后进行一次运算栈弹出；如果是变量名，在解释器检查变量合法(存在且可访问)后按类型打印变量值。
- `arg`
  `arg`命令是函数的专有命令，工作原理类似`var`，接受任意多个变量名作为参数。  
  解释器在确认当前运算栈深度合法后为函数内部临时变量绑定运算栈内的值来实现参数的传递。绑定的顺序：参数表从右到左，栈从上到下。
- `ret`
  `ret`命令是函数的专有命令，它事实上是函数的出口，接受变量名或"~"代表的栈顶元素或立即数作为参数。  
  解释器在函数返回时会根据`old_sp`栈栈顶和次栈顶记录值的差值来在变量栈中顺序释放所有的局部变量，同时弹出程序指针栈的栈顶元素来实现函数的跳出以及主调函数的运行状态的恢复。

## 8. 用户界面  

`pip install pyinstaller`
`pyinstaller -F app.py`打包，前后端分离

考虑到开发时间成本与表现力，我们选择了采用web技术来构建用户界面。 目前在开发人员间流行的Visual Studio Code也是通过web技术实现的。此外，在本课程设计项目中采用web技术还有便于演示的优势，web技术提供的跨平台支持可以解决可能存在的兼容性与依赖问题。  

在本项目的浏览器-服务器架构中用户提交的代码会在服务器端进行编译，翻译成中间代码Pcode后解释执行，并把编译结果、生成的中间代码以及执行结果返回用户端。  

服务器端我们考虑到打包分发整合便利性而决定基于Golang1.15选择了Gin框架进行开发，Golang原生的高性能异步服务器已经足以满足我们的需要，同时我们也使用了Nginx反向代理。  

浏览器端我们采用了异步数据传输技术（AJAX）以提高用户体验，用户在提交代码后不会感受到页面阻塞，依旧能进行其他UI操作。  

用户提交的数据分为源码和输入数据，Python通过调用C++编译得到的动态库（基于ctypes）在运行时阶段将输入字符串重定向到标准输入交给解释器，解释器将运行结果返回给Python服务器，从而将结果返回给用户。 此外用户还可以选择日志级别，分别有"debug,info,warning,error,fatal"，这允许用户自由地选择希望获得的输出，同时也可以通过观察调试日志来发现并解决潜在的问题。

服务器部署：见README.MD
