# Cmm 编译器文档

本文档包含本项目编译器从词法分析到中间代码生成与执行，和最后ui的全部技术内容。

## 目录 <!-- omit in toc -->

- [Cmm 编译器文档](#cmm-编译器文档)
  - [1. 项目概述](#1-项目概述)
    - [1.1. 功能概述](#11-功能概述)
    - [1.2. 代码结构](#12-代码结构)
  - [2. 词法分析](#2-词法分析)
    - [2.1. 自动构造DFA](#21-自动构造dfa)
    - [2.2. 词法规则整理](#22-词法规则整理)
    - [2.3. 字典树](#23-字典树)
    - [2.4. 类正则表达式生成DFA](#24-类正则表达式生成dfa)
  - [3. 语法分析](#3-语法分析)
  - [4. 语义分析](#4-语义分析)
  - [5. 中间代码生成](#5-中间代码生成)
  - [6. 解释执行](#6-解释执行)
  - [7. 用户界面](#7-用户界面)

## 1. 项目概述

### 1.1. 功能概述

见 [README.md](../README.md)

### 1.2. 代码结构

项目主体分为两个部分，编译器/解释器部分和前端部分。  

```text
.
├── run.sh       启动脚本
├── compiler     编译器/解释器部分
└── webservice   前端UI部分
```

编译器部分：

```text
.
├── compiler.exe      编译器可执行文件
├── language.txt      词法规则
├── compiler.cpp      编译器入口
├── automaton.h       词法分析部分
├── automaton.cpp
├── translator.h      语法、语义部分
├── translator.cpp
├── symbol_table.h    符号表部分
├── symbol_table.cpp
└── cLogger           log模块
    ├── clogger.cpp
    └── clogger.h

```

UI部分：

```text
.
├── 1.cpp
├── app.py
├── notes.md
├── placeholder.png
├── requirements.txt
├── static
│   └── comp.js
└── templates
    └── index.html
```

## 2. 词法分析

### 2.1. 自动构造DFA

词法分析需要将代码中的字符分割成单词，然后返回给上层的语法分析进行进一步的处理。
在语法分析的阶段，不仅需要正确获取单词，还要可以正确的处理错误单词和文件结尾。

朴素的词法分析是通过代码根据读入的字符进行处理，整个过程依靠if-else，类似与DFA的处理流程。
但是这样的处理方的问题在于，代码量与词法规则的复杂程度直接相关，并且一个复杂的关键字会对应代码中一段很深的if嵌套。
当然这种方法非常容易实现，但是所处理的词法与代码的强耦合是没有必要的。

这里我们通过读入词法规则，自动构建DFA，从而进行词法分析。
这样做的好处是：
词法与代码解耦合，可以方便的变更词法，包括对符号构成的运算符进行变更，如'{'改为'begin'；
代码与数据分离，方便代码的编写，提高代码重用程度；
相比于单独查表判断是关键字还是标识符，DFA效率更高。

### 2.2. 词法规则整理

首先我们整理了词法规则，将词法规则分为两类，
一类为简单的固定规则，如‘int’，‘char’，‘==’，‘{’等确定的运算符或关键字；
另一类为动态规则，标识符、数字、字符串常量、字符常量，并不是以固定的一种字符串形式出现的单词。  
词法规则见[词法规则表](../compiler/language.txt)

部分固定的词法规则：

```test
CONSTTK const
INTTK int
CHARTK char
VOIDTK void
MAINTK main

IFTK if
ELSETK else
WHILETK while
FORTK for
PLUS +
MINU -

LBRACE {
RBRACE }
```

动态的词法规则：

```text
IDENFR _a~zA~Z|_a~zA~Z0~9
INTCON 0~9
CHARCON '|+-*/_a~zA~Z0~9|'
STRCON "|\032\033\035~\126|"
```

对于固定的单词，我们使用字典树的方式维护这些运算符和关键字。
对于动态的单词，我们定义了一种类似正则表达式的式子，
通过这些式子描述词法，然后在字典树的基础上生成DFA。

### 2.3. 字典树

字典树是一种树型数据结构，树上的每一个节点表示一个状态，每一条边表示一个字符，
从树根到当前节点的路径上的字符组成了一个字符串。
一个字典树的例子如下。
![字典树示例](img/trie_tree.svg)

如图从1到6号节点的路径对应了单词“const”。

词法分析程序从根节点开始，按照读入的字符，沿字典树前进。
如果读入字符串可以匹配一个关键字，那么它会沿字典树走到相应状态，
如果在一个合法的单词结尾处失配，那么说明当前的一个单词已经读完，
否则说明读入了一个错误的单词。
我们在每个合法的单词结尾处标记了单词的类别，
这样在得到一个合法单词之后，可以直接得到对应的类别码。

可以看到，具有相同前缀的字符串共用祖先节点，所以不会出现需要反复匹配前缀的情况，提高了词法分析的处理效率。
同时字典树可以很方便地插入新单词，可以直接从文件中读出单词然后生成字典树。

### 2.4. 类正则表达式生成DFA

我们定义了一种类似正则表达式的语句来描述动态单词的词法。
示例如下：

```text
IDENFR _a~zA~Z|_a~zA~Z0~9
INTCON 0~9
CHARCON '|+-*/_a~zA~Z0~9|'
STRCON "|\032\033\035~\126|"
```

通过‘|’将表达式分为1到3个部分。每一个部分内表示可以被接受的字符范围，
如“_a~zA~Z”表示下划线、全部小写字母、全部大写字母；
“\032\033\035~\126”表示ASCII码为32，33，35到126的全部字符。

如果表达式只有一段，那么这个单词由这一段可接受字符重复组合而成，如可以前导0的数字。
如果有两段，这个单词由一个第一段可接受字符和一些第二段可接受字符组成，如第一位不可以是数字的标识符。
如果有三段，则这个单词可以由一个第一段字符开始，第二段字符在中间，一个第三段字符结束，如引号引起的字符串。

这样的设计并不复杂，可以描述出需要的动态单词的词法，并且也很好修改，
同时还为未来可能的全功能正则表达式支持留下接口。

在成功读入词法信息后，我们在字典树的基础上添加一些边，使得树形结构变成一个能够接受动态单词DFA。
![DFA图例](img/DFA.svg)
如图我们添加了一个点11，表示一个“标识符”，我们将失配但是符合标识符规则的节点全部连过来，
这样无论在任何一个状态下，发现读入单词不是一个关键字的时候，状态都可以正常的转移到标识符处。
其他几种词法同理。

## 3. 语法分析

## 4. 语义分析

## 5. 中间代码生成

通过查阅与参考相关资料我们设计了一种自定义的基于栈和符号表的中间代码pcode[]
…………

## 6. 解释执行

在生成中间代码后需要运行之。基于上文定义的简易中间代码文法，我们基于C++设计并实现了一个Pcode虚拟机。它包括运行时变量栈、运行时变量速查表、运行时全局变量速查表、运行时运算栈、标签表、函数表、代码表、运行时代码指针、运行时栈变量栈指针。  

Pcode的所有命令都是对运行时栈顶及其附近的元素进行操作的
解释器实现特性：通过栈套map来实现动态作用域，通过eip栈实现函数跳出，通过old_sp栈实现运行时变量栈查找以及函数退出时运行时栈内临时变量清空，通过varlookup哈希表来实现O1速查，在处理每一行pcode的时候使用一个unordered map来实现命令对处理函数的映射，避免嵌套ifelse或switchcase
……
debug过程中的回归测试
测试用例:错误类型，使用未声明变量，尝试改变const，调用未声明的函数func（过程），跳转到不存在的标签label，试图使用超过栈深度的栈顶值，尝试在同一作用域内重复声明变量，尝试push不是变量/数字的字符串
性能评测/对比

## 7. 用户界面  

考虑到开发时间成本与表现力，我们选择了采用web技术来构建用户界面。 目前在开发人员间流行的Visual Studio Code也是通过web技术实现的。此外，在本课程设计项目中采用web技术还有便于演示的优势，web技术提供的跨平台支持可以解决可能存在的兼容性与依赖问题。  

在本项目的浏览器-服务器架构中用户提交的代码会在服务器端进行编译，翻译成中间代码pcode后解释执行，并把执行结果返回用户端。  

服务器端我们基于Python3.7选择了Flask框架进行开发，采用了uWSGI作为服务器，同时使用了Nginx反向代理。  

浏览器端我们采用了异步数据传输技术（AJAX）以提高用户体验，用户在提交代码后不会感受到页面阻塞，依旧能进行其他UI操作。  

用户提交的数据分为源码和输入数据，Python通过调用C++编译得到的动态库（基于ctypes）在运行时阶段将输入字符串重定向到标准输入交给解释器，解释器将运行结果返回给Python服务器，从而将结果返回给用户。
