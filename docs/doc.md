# Cmm 编译器文档

本文档包含本项目编译器从词法分析到中间代码生成与执行，和最后ui的全部技术内容。

## 目录 <!-- omit in toc -->

- [1. 项目概述](#1-项目概述)
  - [1.1. 概述](#11-概述)
  - [1.2. 功能概述](#12-功能概述)
  - [1.3. 代码结构](#13-代码结构)
- [2. 词法分析](#2-词法分析)
  - [2.1. 自动构造DFA](#21-自动构造dfa)
  - [2.2. 词法规则整理](#22-词法规则整理)
  - [2.3. 字典树](#23-字典树)
  - [2.4. 类正则表达式生成DFA](#24-类正则表达式生成dfa)
- [3. 语法分析](#3-语法分析)
- [4. 语义分析](#4-语义分析)
- [5. 中间代码定义](#5-中间代码定义)
  - [5.1. 变量声明](#51-变量声明)
  - [5.2. 栈操作](#52-栈操作)
  - [5.3. 数据运算](#53-数据运算)
  - [5.4. 输入输出](#54-输入输出)
  - [5.5. 退出](#55-退出)
  - [5.6. 跳转](#56-跳转)
  - [5.7. 自定义函数](#57-自定义函数)
- [6. 中间代码生成](#6-中间代码生成)
- [7. 解释执行](#7-解释执行)
  - [7.1. 主要数据结构](#71-主要数据结构)
  - [7.2. 简要说明](#72-简要说明)
  - [7.3. 主要命令处理实现](#73-主要命令处理实现)
- [8. 用户界面](#8-用户界面)

## 1. 项目概述

### 1.1. 概述

### 1.2. 功能概述

见 [README.md](../README.md)

### 1.3. 代码结构

项目主体分为两个部分，编译器/解释器部分和前端部分。  

```text
.
├── run.sh       启动脚本
├── compiler     编译器/解释器部分
└── webservice   前端UI部分
```

编译器部分：

```text
.
├── compiler.exe      编译器可执行文件
├── language.txt      词法规则
├── compiler.cpp      编译器入口
├── automaton.h       词法分析部分
├── automaton.cpp
├── translator.h      语法、语义部分
├── translator.cpp
├── symbol_table.h    符号表部分
├── symbol_table.cpp
└── cLogger           log模块
    ├── clogger.cpp
    └── clogger.h

```

UI部分：

```text
.
├── 1.cpp
├── app.py
├── notes.md
├── placeholder.png
├── requirements.txt
├── static
│   └── comp.js
└── templates
    └── index.html
```

## 2. 词法分析

### 2.1. 自动构造DFA

词法分析需要将代码中的字符分割成单词，然后返回给上层的语法分析进行进一步的处理。
在语法分析的阶段，不仅需要正确获取单词，还要可以正确的处理错误单词和文件结尾。

朴素的词法分析是通过代码根据读入的字符进行处理，整个过程依靠if-else，类似与DFA的处理流程。
但是这样的处理方的问题在于，代码量与词法规则的复杂程度直接相关，并且一个复杂的关键字会对应代码中一段很深的if嵌套。
当然这种方法非常容易实现，但是所处理的词法与代码的强耦合是没有必要的。

这里我们通过读入词法规则，自动构建DFA，从而进行词法分析。
这样做的好处是：
词法与代码解耦合，可以方便的变更词法，包括对符号构成的运算符进行变更，如'{'改为'begin'；
代码与数据分离，方便代码的编写，提高代码重用程度；
相比于单独查表判断是关键字还是标识符，DFA效率更高。

### 2.2. 词法规则整理

首先我们整理了词法规则，将词法规则分为两类，
一类为简单的固定规则，如‘int’，‘char’，‘==’，‘{’等确定的运算符或关键字；
另一类为动态规则，标识符、数字、字符串常量、字符常量，并不是以固定的一种字符串形式出现的单词。  
词法规则见[词法规则表](../compiler/language.txt)

部分固定的词法规则：

```test
CONSTTK const
INTTK int
CHARTK char
VOIDTK void
MAINTK main

IFTK if
ELSETK else
WHILETK while
FORTK for
PLUS +
MINU -

LBRACE {
RBRACE }
```

动态的词法规则：

```text
IDENFR _a~zA~Z|_a~zA~Z0~9
INTCON 0~9
CHARCON '|+-*/_a~zA~Z0~9|'
STRCON "|\032\033\035~\126|"
```

对于固定的单词，我们使用字典树的方式维护这些运算符和关键字。
对于动态的单词，我们定义了一种类似正则表达式的式子，
通过这些式子描述词法，然后在字典树的基础上生成DFA。

### 2.3. 字典树

字典树是一种树型数据结构，树上的每一个节点表示一个状态，每一条边表示一个字符，
从树根到当前节点的路径上的字符组成了一个字符串。
一个字典树的例子如下。
![字典树示例](img/trie_tree.svg)

如图从1到6号节点的路径对应了单词“const”。

词法分析程序从根节点开始，按照读入的字符，沿字典树前进。
如果读入字符串可以匹配一个关键字，那么它会沿字典树走到相应状态，
如果在一个合法的单词结尾处失配，那么说明当前的一个单词已经读完，
否则说明读入了一个错误的单词。
我们在每个合法的单词结尾处标记了单词的类别，
这样在得到一个合法单词之后，可以直接得到对应的类别码。

可以看到，具有相同前缀的字符串共用祖先节点，所以不会出现需要反复匹配前缀的情况，提高了词法分析的处理效率。
同时字典树可以很方便地插入新单词，可以直接从文件中读出单词然后生成字典树。

### 2.4. 类正则表达式生成DFA

我们定义了一种类似正则表达式的语句来描述动态单词的词法。
示例如下：

```text
IDENFR _a~zA~Z|_a~zA~Z0~9
INTCON 0~9
CHARCON '|+-*/_a~zA~Z0~9|'
STRCON "|\032\033\035~\126|"
```

通过‘|’将表达式分为1到3个部分。每一个部分内表示可以被接受的字符范围，
如“_a~zA~Z”表示下划线、全部小写字母、全部大写字母；
“\032\033\035~\126”表示ASCII码为32，33，35到126的全部字符。

如果表达式只有一段，那么这个单词由这一段可接受字符重复组合而成，如可以前导0的数字。
如果有两段，这个单词由一个第一段可接受字符和一些第二段可接受字符组成，如第一位不可以是数字的标识符。
如果有三段，则这个单词可以由一个第一段字符开始，第二段字符在中间，一个第三段字符结束，如引号引起的字符串。

这样的设计并不复杂，可以描述出需要的动态单词的词法，并且也很好修改，
同时还为未来可能的全功能正则表达式支持留下接口。

在成功读入词法信息后，我们在字典树的基础上添加一些边，使得树形结构变成一个能够接受动态单词DFA。
![DFA图例](img/DFA.svg)
如图我们添加了一个点11，表示一个“标识符”，我们将失配但是符合标识符规则的节点全部连过来，
这样无论在任何一个状态下，发现读入单词不是一个关键字的时候，状态都可以正常的转移到标识符处。
其他几种词法同理。

## 3. 语法分析

## 4. 语义分析

## 5. 中间代码定义

通过查阅与参考相关资料我们设计了一种自定义的结合了逆波兰式的逻辑和pascal编译器的中间代码的，基于栈和符号表的中间代码，我们称之为PCode。  
PCode的命令格式为`"命令 操作数"`，其中操作数可以是数字(int32)或变量名。PCode的注释类似汇编，以“；”开头的命令会被忽略。  
Pcode的所有命令都是对栈顶及附近的元素进行操作的。PCode的命令共有7类：变量声明、入栈出栈、数据运算、输入输出、退出、跳转、自定义函数。下面分别详细介绍上述7种命令。

### 5.1. 变量声明

通过`var`命令声明变量，并分配需要的空间。有以下用法：  

```pcode
var a           ; 栈顶向下增长 1 个单元，将新的栈顶单元分配（绑定）给 a
var x, y, z     ; 栈顶向下增长 3 个单元，将新的栈顶单元分配（绑定）给 x, y, z
```

### 5.2. 栈操作

`push / pop` 命令，将元素放入栈顶，或取出栈顶元素。有以下用法：

```pcode
push 2          ; 将常数 2 入栈
push a          ; 将变量 a 的值入栈， a 必须已被声明、且已被赋值过
pop             ; 将栈顶向上减少一个单位
pop a           ; 取出栈顶元素，并赋给变量 a ， a 必须已被声明
```

### 5.3. 数据运算

`add / sub / mul / div / mod / cmpeq / cmpne / cmpgt / cmplt / cmpge / cmple / and / or / not / neg` 命令，包括算术、比较和逻辑运算命令。对应于C语言的以下运算符：`+, -, *, /, %, ==, !=, >, <, >=, <=, &&, ||, !, -`  

以上命令中，除 `not` 和 `neg` 命令外，其余命令均为二元操作命令，先取出栈顶两个元素，进行运算后，再将结果放回栈顶， `not` 和 `neg` 命令则为一元操作命令，只对栈顶一个元素进行操作。所有二元操作中， 原栈顶元素是第二个操作符 。  
以cmpgt为例：进行的操作是

- 从栈顶取出操作数op1
- 取除新栈顶的操作数op2进行比较
- 如果op1&lt;op2则结果为真，否则为假。
- 将结果写入运算栈顶

### 5.4. 输入输出

`print/input`命令。有以下用法：

```pcode
print a:int       ;输出类型是int的变量a的值
print "Helo"      ;输出字符串
print b:char,"bye";以字符形式输出变量b的值代表的ascii码拼接字符串"bye"
input a:char      ;输入char类型的值赋给变量a
input c:int,b:char;输入int类型的值赋给变量c以及char类型的值赋给变量b
```

### 5.5. 退出

`exit <value:int>|~`命令。有以下用法：

```pcode
exit 5            ;命令解释器直接退出，解释器的返回值会是5
exit ~            ;按栈顶元素退出，返回值是栈顶元素值
```

### 5.6. 跳转

`jmp/jz/jnz`命令。

- `jmp` 命令为无条件跳转命令，直接跳转到标签处，用法如下：

```pcode
    jmp Label
    ...
    ...
Label:
    print "jump here"
```

- `jz` 命令为条件跳转命令，先取出栈顶元素，判断其是否为 0 ，若为 0 ，则跳转至标签处，若不为 0 ，则转到下一条命令，用法如下：

```pcode
    push 0
    jz Label
    print "top is not zero"
Label:
    print "top is zero"
```

- `jnz` 命令为条件跳转命令，先取出栈顶元素，判断其是否为 0 ，若为 0 ，则转到下一条命令，若不为 0 ，则跳转至标签处，用法如下：
  
```pcode
    push 1
    jz Label
    print "top is not zero"
Label:
    print "top is zero"
```

### 5.7. 自定义函数

`FUNC / ENDFUNC / arg / ret / $func_name` 命令。
FUNC 和 ENDFUNC 分别为函数开始和结尾，FUNC 后的函数名以 @ 开始，这是为了不与系统命令冲突，因为在 C 语言中有可能会定义一个名为 add 或 push 等和系统命令同名的函数。函数名后接一个冒号。

函数体内开始的第一个命令为 arg ，这是声明函数参数的，注意此命令不能和 FUNC 行写在同一行。如果函数没有参数，则此命令可以去掉。声明了函数参数，函数内部可以根据参数名来引用函数调用者传递进来的参数。

函数调用的时候，在函数名前加 `"$"`就可以了，函数的参数通过栈传递，先从左向右将参数压入栈中，再调用函数。用法如下：

```pcode
push 1
push 2
$sum
 
FUNC @sum:
    arg a, b
 
    push a
    push b
    add
    ret ~
ENDFUNC
```

函数用 ret 命令向调用者返回值，有以下形式：

```pcode
ret         ; 返回空值 “/”
ret 1       ; 返回常数
ret a       ; 返回变量值
ret ~       ; 取出栈顶元素，返回其值。
```

## 6. 中间代码生成

如上文的定义，我们给出如下基于栈操作和运算操作的示例：push/pop 命令分别将元素入栈和出栈，add 命令将栈顶的两个元素取出，相加后再放回栈顶。
如：

```x = 1 + 2 * 3;```

可以翻译成以下PCode：

```pcode
push 1
push 2
push 3
mul
add
pop x
```

## 7. 解释执行

在生成中间代码后需要运行之。基于上文定义的简易中间代码语法，我们基于C++设计并实现了一个PCode解释器。

### 7.1. 主要数据结构

由于PCode的所有命令都是对运行时栈顶及其附近的元素进行操作的，我们的解释器也以栈为主要数据结构。它包括:

- 运行时变量栈`std::vector<Variable> runtimeVar`
- 运行时变量速查表`std::stack<std::unordered_map<std::string,int>> runtimeVarLookup`
- 运行时全局变量速查表`std::unordered_map<std::string,int> runtimeGlobLookup`
- 运行时运算栈`std::stack<int> runtimeStack;`
- 标签表`std::unordered_map<std::string,int> labelMap`
- 函数表`std::unordered_map<std::string,int> funcMap`
- 代码表`std::vector<std::vector<std::string>> code`
- 运行时程序指针(PC)`std::stack<int> eip`
- 运行时栈变量栈指针`std::stack<int> old_sp`
- 命令处理函数映射表`std::unordered_map<std::string,int(PcodeInterpreter::*)(const std::string)> cmdHandler`
  
### 7.2. 简要说明

- 两个变量速查表维护的都是变量名对变量栈基址偏移量的映射；标签表和函数表分别维护的是标签名和函数名对代码表基址偏移量的映射。  
- 为了实现函数的递归调用，我们的变量速查表和程序指针都设计成了栈，递归每深入一层就将栈顶的值再次推入栈顶，在函数返回时会弹出栈顶元素(这会在下文中不同命令的实现部分加以进一步说明)。
- 我们通过变量速查表和变量栈来实现变量值的快速访问，同时通过old_sp栈来在函数退出时释放相关局部变量以避免造成内存泄漏。
- 通过维护命令处理函数映射表，我们实现了命令名对处理函数的映射与快速调用`(this->*cmdHandler[cmd[0]])(cmd[1])`。通过使用哈希表实现了相比大段switch-case语句更快的执行速度，同时避免了大段重复代码的编写。
- 解释器在执行代码前会提前遍历一遍PCode，扫描并记录所有标签和函数，并将标签入口和函数入口记录在标签表/函数表中。
  
### 7.3. 主要命令处理实现

- `var`  
  `var`命令接受任意多个逗号分隔的变量名作为参数。  
  解释器会首先在当前栈顶的变量速查表中寻找是否存在重名变量，如果存在则抛出异常并退出；否则将变量填入变量栈中，并把该变量的基址偏移量作为value，变量名作为key填入变量速查表中以实现快速存取访问。
- `push`  
  `push`命令接受一个立即数或变量名作为参数。  
  如果参数不是立即数，解释器会首先在当前栈顶的变量速查表中寻找是否存在该变量名，如果不存在则抛出异常并退出；否则从变量表中取出该变量对应的值(或立即数)填入运行时栈中
- `pop`  
  `pop`命令接受一个变量名作为参数，参数也可为空。  
  解释器会首先检查当前运算栈是否有足够的元素弹出，如果没有则抛出异常并退出。如果参数为空，则直接弹出栈顶元素；如果是变量名，则在检查变量名存在且不是常量后弹出栈顶值并将其赋值给该变量。
- `add`
  `add`命令隐式地使用当前运算栈顶的两个值作为参数。  
  解释器会首先检查当前运算栈是否有两个元素，如果没有则抛出异常并退出。解释器会取出两个栈顶元素相加后填入运算栈中。
- `jmp`
  `jmp`命令为无条件跳转，接受一个标签名作为参数。  
  解释器会首先检查当前标签名是否在标签表中，如果没有则抛出异常并退出。解释器会将当前程序指针栈栈顶元素重新赋值为标签表中记录的过程入口代码表偏移值，会在下一循环中执行标签名所对应的代码段。
- `jz`
  `jz`命令为有条件跳转，只有当前运算栈栈顶值为0时才进行跳转，接受一个标签名作为参数。
  解释器判断并弹出栈顶元素，如果是0则进行跳转(`jmp`)，如果不则继续顺序执行。
- `cmplt`
  `cmplt`命令为比较(小)，隐式地使用当前运算栈顶的两个值作为参数。  
  以cmpgt为例：进行的操作是
  1. 从栈顶取出操作数op1
  2. 取除新栈顶的操作数op2进行比较
  3. 如果op1&lt;op2则结果为真，否则为假。
  4. 将结果写入运算栈顶
- `neg`
  `neg`命令对当前栈顶元素逻辑取反  
  解释器在检查栈内元素个数大于0后对运算栈顶元素逻辑取反。
- `print`
  `print`命令接受"`"分隔的任意多个变量名、""包裹的字符串或"~"代表的栈顶元素作为参数。  
  如果是字符串，则直接打印输出；如果是栈顶元素，在取出栈顶元素值并判断类型后进行一次运算栈弹出；如果是变量名，在解释器检查变量合法(存在且可访问)后按类型打印变量值。
- `arg`
  `arg`命令是函数的专有命令，工作原理类似`var`，接受任意多个变量名作为参数。  
  解释器在确认当前运算栈深度合法后为函数内部临时变量绑定运算栈内的值来实现参数的传递。绑定的顺序：参数表从右到左，栈从上到下。
- `ret`
  `ret`命令是函数的专有命令，它事实上是函数的出口，接受变量名或"~"代表的栈顶元素或立即数作为参数。  
  解释器在函数返回时会根据`old_sp`栈栈顶和次栈顶记录值的差值来在变量栈中顺序释放所有的局部变量，同时弹出程序指针栈的栈顶元素来实现函数的跳出以及主调函数的运行状态的恢复。

## 8. 用户界面  

`pip install pyinstaller`
`pyinstaller -F app.py`打包，前后端分离

考虑到开发时间成本与表现力，我们选择了采用web技术来构建用户界面。 目前在开发人员间流行的Visual Studio Code也是通过web技术实现的。此外，在本课程设计项目中采用web技术还有便于演示的优势，web技术提供的跨平台支持可以解决可能存在的兼容性与依赖问题。  

在本项目的浏览器-服务器架构中用户提交的代码会在服务器端进行编译，翻译成中间代码Pcode后解释执行，并把编译结果、生成的中间代码以及执行结果返回用户端。  

服务器端我们考虑到打包分发整合便利性而决定基于Golang1.15选择了Gin框架进行开发，Golang原生的高性能异步服务器已经足以满足我们的需要，同时我们也使用了Nginx反向代理。  

浏览器端我们采用了异步数据传输技术（AJAX）以提高用户体验，用户在提交代码后不会感受到页面阻塞，依旧能进行其他UI操作。  

用户提交的数据分为源码和输入数据，Python通过调用C++编译得到的动态库（基于ctypes）在运行时阶段将输入字符串重定向到标准输入交给解释器，解释器将运行结果返回给Python服务器，从而将结果返回给用户。 此外用户还可以选择日志级别，分别有"debug,info,warning,error,fatal"，这允许用户自由地选择希望获得的输出，同时也可以通过观察调试日志来发现并解决潜在的问题。

服务器部署：见README.MD
